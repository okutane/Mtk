using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Matveev.Mtk.Core;

namespace Matveev.Mtk.Library.Fields
{
    public class CompactQuadraticForm : IImplicitSurface
    {
        private readonly double _a11;
        private readonly double _a12;
        private readonly double _a13;
        private readonly double _a22;
        private readonly double _a23;
        private readonly double _a33;
        private readonly double _b1;
        private readonly double _b2;
        private readonly double _b3;
        private readonly double _c;

        public CompactQuadraticForm(double[,] a, double[] b, double c)
        {
            _a11 = a[0, 0];
            _a12 = (a[0, 1] + a[1, 0]) / 2;
            _a13 = (a[0, 2] + a[2, 0]) / 2;
            _a22 = a[1, 1];
            _a23 = (a[1, 2] + a[2, 1]) / 2;
            _a33 = a[2, 2];
            _b1 = b[0];
            _b2 = b[1];
            _b3 = b[2];
            _c = c;
        }

        #region IImplicitSurface Members

        public double Eval(Point p)
        {
            return EvaluateA(p, p) + EvaluateB(p) + _c;
        }

        public Vector Grad(Point p)
        {
            return new Vector(
                2 * _a11 * p.X + _a12 * p.Y + _a13 * p.Z + _b1,
                _a12 * p.X + 2 * _a22 * p.Y + _a23 * p.Z + _b2,
                _a13 * p.X + _a23 * p.Y + 2 * _a33 * p.Z + _b3);
        }

        #endregion

        public double FaceDistance(Point[] points)
        {
            Point x0 = points[0];
            Point e1 = points[1] - x0;
            Point e2 = points[2] - x0;

            double a1 = EvaluateA(e1, e1);
            double a2 = EvaluateA(e2, e2);
            double a3 = 2 * EvaluateA(e1, e2);
            double b1 = EvaluateB(e1) + 2 * EvaluateA(x0, e1);
            double b2 = EvaluateB(e2) + 2 * EvaluateA(x0, e2);
            double c = Eval(x0);

            /* Code below was generated by Maple. Original expression:
             * int(int(f(u, v)^2, v = 0..1-u), u = 0..1), where f is defined as follows:
             * f(u, v) := a1 * u^2 + a2 * v^2 + a3 * u * v + b1 * u + b2 * v + c
             */
            double faceDistance = b2 * a3 / 0.30e2 + b2 * b2 / 0.12e2 + c * c / 0.2e1 + a2 * a2 / 0.30e2
                + b2 * a2 / 0.10e2 + a3 * a2 / 0.60e2 + c * a2 / 0.6e1 + b1 * a2 / 0.30e2 + a1 * a2 / 0.90e2
                + a3 * a3 / 0.180e3 + c * b2 / 0.3e1 + c * a3 / 0.12e2 + b1 * b2 / 0.12e2 + b1 * a3 / 0.30e2
                + a1 * b2 / 0.30e2 + a1 * a3 / 0.60e2 + c * b1 / 0.3e1 + c * a1 / 0.6e1 + b1 * b1 / 0.12e2
                + b1 * a1 / 0.10e2 + a1 * a1 / 0.30e2;

            double E = (Vector)e1 * (Vector)e1;
            double G = (Vector)e2 * (Vector)e2;
            double F = (Vector)e1 * (Vector)e2;
            double multiplier = Math.Sqrt(E * G - F * F);

            return faceDistance * multiplier;
        }

        public double[] GradOfFaceDistance(Point[] points)
        {
            Point x0 = points[0];
            Point x1 = points[1];
            Point x2 = points[2];
            Point e1 = points[1] - x0;
            Point e2 = points[2] - x0;

            double a1 = EvaluateA(e1, e1);
            double a2 = EvaluateA(e2, e2);
            double a3 = 2 * EvaluateA(e1, e2);
            double b1 = EvaluateB(e1) + 2 * EvaluateA(x0, e1);
            double b2 = EvaluateB(e2) + 2 * EvaluateA(x0, e2);
            double c = Eval(x0);

            /* Code below was generated by Maple. Original expression:
             * int(int(f(u, v)^2, v = 0..1-u), u = 0..1), where f is defined as follows:
             * f(u, v) := a1 * u^2 + a2 * v^2 + a3 * u * v + b1 * u + b2 * v + c
             */
            double faceDistance = b2 * a3 / 0.30e2 + b2 * b2 / 0.12e2 + c * c / 0.2e1 + a2 * a2 / 0.30e2
                + b2 * a2 / 0.10e2 + a3 * a2 / 0.60e2 + c * a2 / 0.6e1 + b1 * a2 / 0.30e2 + a1 * a2 / 0.90e2
                + a3 * a3 / 0.180e3 + c * b2 / 0.3e1 + c * a3 / 0.12e2 + b1 * b2 / 0.12e2 + b1 * a3 / 0.30e2
                + a1 * b2 / 0.30e2 + a1 * a3 / 0.60e2 + c * b1 / 0.3e1 + c * a1 / 0.6e1 + b1 * b1 / 0.12e2
                + b1 * a1 / 0.10e2 + a1 * a1 / 0.30e2;

            double[] grad = new double[9];

            double[] Ax0 = EvaluateAx(x0);
            double[] Ax1 = EvaluateAx(x1);
            double[] Ax2 = EvaluateAx(x2);
            double[] gradAxx0 = GradAx(x0);
            double[] gradAxx1 = GradAx(x1);
            double[] gradAxx2 = GradAx(x2);
            Vector gradC = Grad(x0);

            double coeff;

            // c
            coeff = c + a2 / 6 + a1 / 6 + b1 / 3 + b2 / 3 + a3 / 12;
            grad[0] += coeff * gradC[0];
            grad[1] += coeff * gradC[1];
            grad[2] += coeff * gradC[2];

            // b2
            coeff = b2 / 6 + a3 / 30 + a2 / 10 + c / 3 + b1 / 12 + a1 / 30;
            grad[0] += coeff * (Ax2[0] - _b1 - gradAxx0[0]);
            grad[1] += coeff * (Ax2[1] - _b2 - gradAxx0[1]);
            grad[2] += coeff * (Ax2[2] - _b3 - gradAxx0[2]);
            grad[6] += coeff * Ax0[0];
            grad[7] += coeff * Ax0[1];
            grad[8] += coeff * Ax0[2];

            // a2
            coeff = a2 / 15 + b2 / 10 + a3 / 60 + c / 6 + b1 / 30 + a1 / 90;
            grad[0] += coeff * (gradAxx0[0] - 2 * Ax2[0]);
            grad[1] += coeff * (gradAxx0[1] - 2 * Ax2[1]);
            grad[2] += coeff * (gradAxx0[2] - 2 * Ax2[2]);
            grad[6] += coeff * (gradAxx2[0] - 2 * Ax0[0]);
            grad[7] += coeff * (gradAxx2[1] - 2 * Ax0[1]);
            grad[8] += coeff * (gradAxx2[2] - 2 * Ax0[2]);

            // a3
            coeff = a3 / 90 + b2 / 30 + a2 / 60 + c / 12 + b1 / 30 + a1 / 60;
            grad[0] += coeff * (2 * gradAxx0[0] - Ax1[0] - Ax2[0]);
            grad[1] += coeff * (2 * gradAxx0[1] - Ax1[1] - Ax2[1]);
            grad[2] += coeff * (2 * gradAxx0[2] - Ax1[2] - Ax2[2]);
            grad[3] += coeff * (2 * Ax2[0] - Ax0[0]);
            grad[4] += coeff * (2 * Ax2[1] - Ax0[1]);
            grad[5] += coeff * (2 * Ax2[2] - Ax0[2]);
            grad[6] += coeff * (2 * Ax1[0] - Ax0[0]);
            grad[7] += coeff * (2 * Ax1[1] - Ax0[1]);
            grad[8] += coeff * (2 * Ax1[2] - Ax0[2]);

            // b1
            coeff = b1 / 6 + a1 / 10 + a2 / 30 + c / 3 + b2 / 12 + a3 / 30;
            grad[0] += coeff * (Ax1[0] - _b1 - gradAxx0[0]);
            grad[1] += coeff * (Ax1[1] - _b2 - gradAxx0[1]);
            grad[2] += coeff * (Ax1[2] - _b3 - gradAxx0[2]);
            grad[3] += coeff * Ax0[0];
            grad[4] += coeff * Ax0[1];
            grad[5] += coeff * Ax0[2];

            // a1
            coeff = a1 / 15 + b1 / 10 + a2 / 90 + c / 6 + a3 / 60 + b2 / 30;
            grad[0] += coeff * (gradAxx0[0] - 2 * Ax1[0]);
            grad[1] += coeff * (gradAxx0[1] - 2 * Ax1[1]);
            grad[2] += coeff * (gradAxx0[2] - 2 * Ax1[2]);
            grad[3] += coeff * (gradAxx1[0] - 2 * Ax0[0]);
            grad[4] += coeff * (gradAxx1[1] - 2 * Ax0[1]);
            grad[5] += coeff * (gradAxx1[2] - 2 * Ax0[2]);

            double E = (Vector)e1 * (Vector)e1;
            double G = (Vector)e2 * (Vector)e2;
            double F = (Vector)e1 * (Vector)e2;
            double multiplier = Math.Sqrt(E * G - F * F);
            double[] multiplierGrad = new double[9];

            multiplierGrad[0] += 2 * G * (x0[0] - x1[0]);
            multiplierGrad[1] += 2 * G * (x0[1] - x1[1]);
            multiplierGrad[2] += 2 * G * (x0[2] - x1[2]);
            multiplierGrad[3] += 2 * G * (x1[0] - x0[0]);
            multiplierGrad[4] += 2 * G * (x1[1] - x0[1]);
            multiplierGrad[5] += 2 * G * (x1[2] - x0[2]);

            multiplierGrad[0] += 2 * E * (x0[0] - x2[0]);
            multiplierGrad[1] += 2 * E * (x0[1] - x2[1]);
            multiplierGrad[2] += 2 * E * (x0[2] - x2[2]);
            multiplierGrad[6] += 2 * E * (x2[0] - x0[0]);
            multiplierGrad[7] += 2 * E * (x2[1] - x0[1]);
            multiplierGrad[8] += 2 * E * (x2[2] - x0[2]);

            multiplierGrad[0] += -2 * F * (2 * x0[0] - x1[0] - x2[0]);
            multiplierGrad[1] += -2 * F * (2 * x0[1] - x1[1] - x2[1]);
            multiplierGrad[2] += -2 * F * (2 * x0[2] - x1[2] - x2[2]);
            multiplierGrad[3] += -2 * F * (x2[0] - x0[0]);
            multiplierGrad[4] += -2 * F * (x2[1] - x0[1]);
            multiplierGrad[5] += -2 * F * (x2[2] - x0[2]);
            multiplierGrad[6] += -2 * F * (x1[0] - x0[0]);
            multiplierGrad[7] += -2 * F * (x1[1] - x0[1]);
            multiplierGrad[8] += -2 * F * (x1[2] - x0[2]);

            for (int i = 0; i < 9; i++)
            {
                grad[i] = multiplier * grad[i] + faceDistance / (2 * multiplier) * multiplierGrad[i];
            }

            return grad;
        }

        private double EvaluateA(Point x, Point y)
        {
            return _a11 * x.X * y.X + _a12 * x.X * y.Y + _a13 * x.X * y.Z
                + _a12 * x.Y * y.X + _a22 * x.Y * y.Y + _a23 * x.Y * y.Z
                + _a13 * x.Z * y.X + _a23 * x.Z * y.Y + _a33 * x.Z * y.Z;
        }

        private double[] EvaluateAx(Point p)
        {
            return new double[] {
                _a11 * p.X + _a12 * p.Y + _a13 * p.Z,
                _a12 * p.X + _a22 * p.Y + _a23 * p.Z,
                _a13 * p.X + _a23 * p.Y + _a33 * p.Z,
            };
        }

        private double[] GradAx(Point p)
        {
            return new double[] {
                2 * _a11 * p.X + _a12 * p.Y + _a13 * p.Z,
                _a12 * p.X + 2 * _a22 * p.Y + _a23 * p.Z,
                _a13 * p.X + _a23 * p.Y + 2 * _a33 * p.Z,
            };
        }

        private double EvaluateB(Point p)
        {
            return _b1 * p.X + _b2 * p.Y + _b3 * p.Z;
        }

        public static readonly CompactQuadraticForm ParabolicHyperboloid =
            new CompactQuadraticForm(new double[,] { { 1, 0, 0 }, { 0, -1, 0 }, { 0, 0, 0 } },
                new double[] { 0, 0, 1 }, 0);

        public static readonly CompactQuadraticForm Sphere =
            new CompactQuadraticForm(new double[,] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } },
                new double[] { 0, 0, 0 }, -1);

        public static readonly CompactQuadraticForm Plane =
            new CompactQuadraticForm(new double[3, 3], new double[] { 0, 1, 0 }, 0);

        public static readonly CompactQuadraticForm HyperboloidOne =
            new CompactQuadraticForm(new double[3, 3] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, -0.9 } },
                new double[3], -0.1);
    }
}
